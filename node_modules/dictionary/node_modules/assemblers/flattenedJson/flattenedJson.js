'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		}

		//INITIALIZE OBJECT ====================================

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'linkPropertyContainerName',
				optional: false
			},
			{
				name: 'attachmentListPropertySpec',
				optional: false
			},
			{
				name: 'destPropertyObjectPropertyName',
				optional: true
			},
			{
				name: 'finalObjectCustomEditor',
				optional: true
			}
		]
	});


	//LOCAL FUNCTIONS ====================================

	var buildObject = function(fieldNameList, sourceObj) {

		var outObj = {};
		for (var i = 0, len = fieldNameList.length; i < len; i++) {
			var element = fieldNameList[i];

			if (fieldNameList[i] === '') {
				continue;
			} //trailing tabs are an epidemic, omit the resulting empty fieldnames

			if (typeof (element[i] != 'undefined')) {
				outObj[fieldNameList[i]] = sourceObj[i];
			} else {

				outObj[fieldNameList[i]] = '';
			}

		}

		return outObj;
	},
	
	getRootName=function(lineList){
		return lineList[0];
	}

	//BUILD RETURN OBJECT ====================================

	this.forceEvent = forceEvent;

	this.importer = function(args) {

		qtools.validateProperties({
			subject: args,
			propList: [
				{
					name: 'lineList',
					optional: false
				},
				{
					name: 'sourceObjectList',
					optional: false
				}
			]
		});

		var outObject = {},
			workingList,
			fieldNameList,
			element, newObject;

		var list = args.lineList;

		for (var i = 0, len = list.length; i < len; i++) {

			if (!list[i].match(/\w/)) {
				continue;
			}

			var isEntityNameRow = list[i].match(/\t/) ? false : true;

			if (i === 0 && !isEntityNameRow) {
				qtools.die(qtools.errorObject("'flattenedJson' format requires section names to be exactly one word, no trailing tabs", element));
			}

			if (isEntityNameRow) {
				outObject[list[i]] = [];

				workingList = outObject[list[i]];
				fieldNameList = list[i + 1].split('\t');

				i = i + 1;

			} else {

				element = list[i].split('\t');
				newObject = buildObject(fieldNameList, element);


				workingList.push(newObject);

				args.sourceObjectList.push(element);
			}


		}

		return outObject;
	}



this.executeAssembling = function(args) {

	qtools.validateProperties({
		subject:args,
		targetScope: this, //will add listed items to targetScope
		propList:[
			{name:'importedObjectList', optional:false, requiredType:'object', assertNotEmptyFlag:true},
			{name:'lineList', optional:false, requiredType:'array', assertNotEmptyFlag:true}
		]
	});
	
	var sourceObjectList=args.importedObjectList;
	var outList = [],
		element, linkPropName, parentObject, linkValue, rootName;
	
	rootName=getRootName(args.lineList);
	outList=sourceObjectList[rootName];

	var list=[];
	for (var i in sourceObjectList){
		if (i==rootName){continue;}
		
		var currentEntityGroupName=i,
			element=sourceObjectList[i],
			linkWorkingObject;
		for (var j in element){
			var property=element[j];
			for (var k in property){
				var value=property[k];
					var count=qtools.count(value),
						linkedObject=args.importedObjectList[k],
						isLinking=(typeof(linkedObject && typeof(linkedObject)=='object')!='undefined')?true:false;
				
				if (!isLinking){ continue;}

				if (typeof(value)=='object'){
					if (isLinking && qtools.count(value)!=1){
						qtools.die(qtools.errorObject("only one property allowed in linking object '"+k+"'", value));
					}
					
					linkWorkingObject=qtools.getByProperty(linkedObject, 'LocalId', qtools.getOnlyProperty(value));


					if (typeof(linkWorkingObject)=='object'){
						if (qtools.toType(linkWorkingObject[currentEntityGroupName])!='array'){
							linkWorkingObject[currentEntityGroupName]=[];

						}
						linkWorkingObject[currentEntityGroupName].push(property);
					}

				}
			}
		}
	}

	if (typeof (self.finalObjectCustomEditor) == 'function') {
		outList = self.finalObjectCustomEditor(outList);
	}


	return outList;
};

this.translator=function(intermediateObjectList, translations){

	for (var entityName in translations){
		var entityTranslationList=translations[entityName],
			sourceList=intermediateObjectList[entityName];

		for (var valuePathString in entityTranslationList){
			var valueTranslationFunction=entityTranslationList[valuePathString];

			for (var i=0, len=sourceList.length; i<len; i++){
				var element=sourceList[i],
					sourceValue=qtools.getSurePath(element, valuePathString),
					newValue=valueTranslationFunction(sourceValue, element);
		
				qtools.putSurePath(element, valuePathString, newValue);
			}
		
		}
	}
	

return intermediateObjectList;
};


	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;


